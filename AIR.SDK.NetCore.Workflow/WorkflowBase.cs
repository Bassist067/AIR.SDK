using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Threading;
using Amazon.SimpleWorkflow;
using Amazon.SimpleWorkflow.Model;
using AIR.SDK.Workflow.Context;
using AIR.SDK.Workflow.Core;
using System.Text.RegularExpressions;
using System.Threading.Tasks;
using AIR.API.Core.Storage;
using AIR.SDK.NetStandard.Workflow.Properties;

namespace AIR.SDK.Workflow
{
	/// <summary>
	/// Represents the base class for implementing workflows. 
	/// It provides an implementation for handling events that allows users to implement 
	/// simple workflows without writing any code once the workflow steps are defined.
	/// </summary>
	public class WorkflowBase : IDecider, IWorkflow
	{
		//private readonly ConcurrentBag<Step> Steps = new ConcurrentBag<Step>();
		//private readonly List<Step> Steps = new List<Step>();
		internal readonly List<IWorkflowStep> Steps = new List<IWorkflowStep>();

		private readonly IAmazonSimpleWorkflow _swfClient;
		private readonly IStorageManager _storageClient;

		private readonly Dictionary<string, CancellationTokenSource> _tokenSources = new Dictionary<string, CancellationTokenSource>(); // new CancellationTokenSource();
		private readonly List<Task> _executedWorkers = new List<Task>();

		// Used to prevent changing list of steps.
		private bool _committed;
		// Indicates if StartWorkflowExecutionRequest has been sent.
		private bool _workflowExecutionStarted;

		private ChildPolicy _childPolicy = ChildPolicy.TERMINATE;
		//private int _taskStartToCloseTimeout = 150;
		//private int _executionStartToCloseTimeout = 300;
		//private int _workflowExecutionRetentionPeriodInDays = 1;

		private bool _checkRegisterTypes = true;
		private bool _useInsideDecider = true;
		private bool _useInsideActivityWorker = true;

		/// <summary>
		/// Unique key represents a path in the parent workflow.
		/// </summary>
		internal string TreePath = "";

		/// <summary>
		/// Occurs when the workflow is about to complete.
		/// </summary>
		public event WorkflowEventHandler WorkflowCompleted;

		/// <summary>
		/// Occurs when the workflow or child workflow failed.
		/// </summary>
		public event WorkflowEventHandler WorkflowFailed;

		/// <summary>
		/// Occurs when an activity failed.
		/// </summary>
		public event ActivityEventHandler ActivityFailed;


		public IWorkflowOptions Options { get; private set; }

		#region Properties

		/// <summary>
		/// A SWF domain. Each SWF entity runs in specific domain.
		/// </summary>
		public string Domain { get { return Options.Domain; } }

		/// <summary>
		/// Unique identifier associated with the workflow execution.
		/// </summary>
		public string WorkflowId { get; set; }

		/// <summary>
		/// The runId of a workflow execution. This ID is generated by the service and 
		/// can be used to uniquely identify the workflow execution within a domain.
		/// </summary>
		public string RunId { get; set; }

		/// <summary>
		///  The name of the workflow type within the domain.
		///  The specified string must not start or end with whitespace. It must not contain
		///  a : (colon), / (slash), | (vertical bar), or any control characters (\u0000-\u001f | \u007f - \u009f). 
		///  Also, it must not contain the literal string quotarnquot.
		/// </summary>
		public string Name { get { return Options.Name; } }

		/// <summary>
		/// Workflow version. Use this for storing the old a new workflow implementations.
		/// </summary>
		public string Version { get { return Options.Version; } }

		/// <summary>
		/// A textual description of the workflow type.
		/// </summary>
		public string Description { get { return Options.Description; } set { Options.Description = value; } }

		/// <summary>
		/// The task list to use for the decision tasks generated for this workflow execution.
		/// It is a grouping key for Amazon  You can set activity workers polling for specific task lists.
		/// </summary>
		public TaskList TaskList { get; private set; }

		/// <summary>
		/// Workflow initial input data.
		/// </summary>
		public string Input { get; set; }

		/// <summary>
		/// Serialized <see cref="IResult<string>"/> output object of the last activity.
		/// </summary>
		public string Result { get; set; }

		//public string Control { get; set; }
		/// <summary>
		/// Tagging enables you to filter your results when you use visibility actions to list or count workflow executions.
		/// </summary>
		public List<string> TagList { get; set; }

		/// <summary>
		/// Gets and sets the property ChildPolicy. 
		/// If set, specifies the policy to use for the child workflow executions of
		/// this workflow execution if it is terminated, by calling the TerminateWorkflowExecution
		/// action explicitly or due to an expired timeout.
		/// </summary>
		public ChildPolicy ChildPolicy
		{
			get { return _childPolicy; }
			set { _childPolicy = value; }
		}


		/// <summary>
		/// This timeout specifies the maximum time that the corresponding decider can take to complete a decision task.
		/// The duration is specified in seconds; an integer greater than or equal to 0. 
		/// A negative value (e.g. -1) can be used to specify unlimited duration.
		/// If this timeout is exceeded, the task is marked as timed out in the workflow execution history, 
		/// and Amazon SWF adds an event of type DecisionTaskTimedOut to the workflow history.
		/// </summary>
		//public int TaskStartToCloseTimeout
		//{
		//	get { return _taskStartToCloseTimeout; }
		//	set { _taskStartToCloseTimeout = value; }
		//}

		/// <summary>
		/// This timeout specifies the maximum time that a workflow execution can take to complete.
		/// The duration is specified in seconds; an integer greater than or equal to 0. 
		/// If this timeout is exceeded, Amazon SWF closes the workflow execution and adds an event of type WorkflowExecutionTimedOut 
		/// to the workflow execution history. In addition to the timeoutType, the event attributes specify the childPolicy 
		/// that is in effect for this workflow execution.
		/// </summary>
		//public int ExecutionStartToCloseTimeout
		//{
		//	get { return _executionStartToCloseTimeout; }
		//	set { _executionStartToCloseTimeout = value; }
		//}

		/// <summary>
		/// The duration (in days) that records and histories of workflow executions on the domain should be kept by the service. 
		/// After the retention period, the workflow execution is not available in the results of visibility calls.
		/// If you pass the 0 (zero), then the workflow execution history will not be retained. As soon as the workflow execution completes, 
		/// the execution record and its history are deleted.
		/// The maximum workflow execution retention period is 90 days.
		/// </summary>
		//public int WorkflowExecutionRetentionPeriodInDays
		//{
		//	get { return _workflowExecutionRetentionPeriodInDays; }
		//	set { _workflowExecutionRetentionPeriodInDays = value; }
		//}

		/// <summary>
		/// Used to retry running workflow. If exceeds, workflow is considered to be failed.
		/// </summary>
		public int MaxAttempts { get { return Options.MaxAttempts; } set { Options.MaxAttempts = value; } }

		/// <summary>
		/// Indicates whether all activity and workflow types should be checked and registered on SWF 
		/// before the main workflow is started.
		/// Default value is True. 
		/// </summary>
		public bool CheckRegisterTypes
		{
			get { return _checkRegisterTypes; }
			set { _checkRegisterTypes = value; }
		}

		/// <summary>
		/// Indicates whether the inside decider will be started while the workflow execution is being started.
		/// Defalut value is True.
		/// </summary>
		public bool UseInsideDecider
		{
			get { return _useInsideDecider; }
			set { _useInsideDecider = value; }
		}

		/// <summary>
		/// Indicates whether the inside activity worker will be started while the workflow execution is being started.
		/// Defalut value is True.
		/// </summary>
		public bool UseInsideActivityWorker
		{
			get { return _useInsideActivityWorker; }
			set { _useInsideActivityWorker = value; }
		}

		/// <summary>
		/// The property used for implemented complex workflow logic such as conditionals.
		/// </summary>
		/// <remarks>
		/// <param name="stepKey">Unique key of current workflow step. <see cref="WorkflowBase.AttachStep(string, ISchedulable)"/></param>
		/// <param name="prevStepResult">A serialized current workflow output data.</param>
		/// <returns>Unique key of the next step to be scheduled.</returns>
		/// </remarks>
		/// <seealso cref="WorkflowBase.GetNextStep()"/>
		//public Func<string, string, IResult<object>> NextStepHandler { get; set; }


		/// <summary>
		/// A main method used for implemented complex workflow logic such as conditionals.
		/// </summary>
		/// <param name="stepKey">Unique key of current workflow step. <see cref="WorkflowBase.AttachStep(string, ISchedulable)"/></param>
		/// <param name="prevStepResult">A serialized current workflow output data.</param>
		/// <returns>Unique key of the next step to be scheduled.</returns>
		/// <remarks>If the method is not overridden or returns empty value, then the next step in the Steps list will be scheduled.</remarks>
		public virtual IResult<object> GetNextStep(string stepKey, string prevStepResult) 
		{
			if (Options == null)
				throw new Exception("Options is undefined");

			return Options.NextStepHandler?.Invoke(stepKey, prevStepResult);
		}

		#endregion

		public WorkflowBase(IWorkflowOptions options, IAmazonSimpleWorkflow swfClient)
			: this(options, swfClient, null) 
		{
		}

		public WorkflowBase(string domain, string workflowName, string version, string tasklistName, IAmazonSimpleWorkflow swfClient)
			: this(domain, workflowName, version, tasklistName , swfClient, null)
		{
		}
		/// <summary>
		/// Initializes a new instance of the <see cref="ll.SDK.Workflow.WorkflowBase"/> class.
		/// </summary>
		/// <param name="domain">A SWF domain. <see cref="WorkflowBase.Domain"/></param>
		/// <param name="workflowName">Name of the workflow type within the domain. <see cref="WorkflowBase.Name"/></param>
		/// <param name="version">Workflow version. <see cref="WorkflowBase.Version"/></param>
		/// <param name="taskList">The task list for this workflow execution. <see cref="WorkflowBase.TaskList"/></param>
		/// <param name="swfClient">IAmazonSimmpleWorkflow</param>
		/// <param name="storeManager">IStorageManager</param>
		public WorkflowBase(string domain, string workflowName, string version, string tasklistName, IAmazonSimpleWorkflow swfClient, IStorageManager storeManager)
			: this(new WorkflowOptions
			{
				Domain = domain,
				Name = workflowName,
				Version = version,
				TaskList = tasklistName
			}, swfClient, storeManager)
		{
		}

		/// <summary>
		/// Initializes a new instance of the <see cref="ll.SDK.Workflow.WorkflowBase"/> class.
		/// </summary>
		/// <param name="domain">A SWF domain. <see cref="WorkflowBase.Domain"/></param>
		/// <param name="workflowName">Name of the workflow type within the domain. <see cref="WorkflowBase.Name"/></param>
		/// <param name="version">Workflow version. <see cref="WorkflowBase.Version"/></param>
		/// <param name="taskList">The task list for this workflow execution. <see cref="WorkflowBase.TaskList"/></param>
		/// <param name="swfClient">IAmazonSimmpleWorkflow</param>
		public WorkflowBase(IWorkflowOptions workflowOptions, IAmazonSimpleWorkflow swfClient, IStorageManager storageManager)
		{
			if (swfClient == null)
				throw new ArgumentNullException(nameof(swfClient));

			if (workflowOptions == null)
				throw new ArgumentNullException(nameof(workflowOptions));

			ValidateTypes();

			Options = workflowOptions;

			TaskList = new TaskList { Name = workflowOptions.TaskList };

			_swfClient = swfClient;
			_storageClient = storageManager; 
		}

		#region IDecider Methods

		private RespondDecisionTaskCompletedRequest Respond(StepDecision stDecision)
		//List<Decision> decisions, WorkflowState wfState)
		{
			Debug.Assert(stDecision != null);

			if (stDecision.WfState != null && stDecision.WfState.NumberOfActions == 0)
			{
				stDecision.Add(CompleteWorkflow(""));
			}

			if (stDecision.Decisions.Any(d => d.DecisionType == DecisionType.FailWorkflowExecution))
			{
				StopWorkers();
				_workflowExecutionStarted = false;
			}

			// Check for complete workflow decision to stop workflow.
			if (stDecision.Decisions.Any(d => d.DecisionType == DecisionType.CompleteWorkflowExecution))
			{
				StopWorkers();

				if (!string.IsNullOrEmpty(RunId))
				{
					_workflowExecutionStarted = false;
				}
			}

			return new RespondDecisionTaskCompletedRequest
			{
				Decisions = stDecision.Decisions,
				//ExecutionContext = WorkflowStateSerializer.Serialize(stDecision.WfState)
			};
		}

		/// <summary>
		/// Sets up a new activity or child workflow as specified by the workflow at the start of the workflow.
		/// </summary>
		/// <param name="context">Workflow decision context supplied by SimpleWorkflowFramework.NET.</param>
		/// <returns>Properly set up decision completed request.</returns>
		RespondDecisionTaskCompletedRequest IDecider.OnWorkflowExecutionStarted(WorkflowDecisionContext context)
		{
			try
			{
				// Notice, the event also occurs for the Child Workflow Execution.

				// Do nothing for a child workflow because it will be processed in OnChildWorkflowExecutionStarted.
				//if (!string.IsNullOrEmpty(context.WorkflowParentId))
				//	return EmptyDecision();

				// Start with the first item in the workflow steps
				StepDecision res = ScheduleStep(0, context.Input, 0);

				return Respond(res);
			}
			catch (Exception ex)
			{
				return FailWorkflowRespond(ex.Message, "");
			}
		}

		/// <summary>
		/// Sets up a new activity or child workflow as specified by the workflow at the re-start of the workflow.
		/// </summary>
		/// <param name="context">Workflow decision context supplied by SimpleWorkflowFramework.NET.</param>
		/// <returns>Properly set up decision completed request.</returns>
		RespondDecisionTaskCompletedRequest IDecider.OnWorkflowExecutionContinuedAsNew(WorkflowDecisionContext context) { return ((IDecider)this).OnWorkflowExecutionStarted(context); }

		/// <summary>
		/// Set up a cancel workflow decision in the event of cancelation of the workflow.
		/// </summary>
		/// <param name="context">Workflow decision context supplied by SimpleWorkflowFramework.NET.</param>
		/// <returns>Properly set up decision completed request.</returns>
		RespondDecisionTaskCompletedRequest IDecider.OnWorkflowExecutionCancelRequested(WorkflowDecisionContext context) { return CancelWorkflowRespond(context.Details); }


		/// <summary>
		/// Set up a cancel workflow decision in the event of cancelation of the workflow.
		/// </summary>
		/// <param name="context">Workflow decision context supplied by SimpleWorkflowFramework.NET.</param>
		/// <returns>Properly set up decision completed request.</returns>
		RespondDecisionTaskCompletedRequest IDecider.OnWorkflowExecutionCompleted(WorkflowDecisionContext context)
		{
			#if DEBUG
			Logger.Fatal("Context Dump: {0}", context.dd());
			#endif
			return EmptyDecision();
			//CancelWorkflowRespond(context.Details);
		}


		/// <summary>
		/// Handles the activity task completed event.
		/// Sets up a new activity or child workflow as specified by the workflow at the completion of an activity.
		/// </summary>
		/// <param name="context">Workflow decision context supplied by SimpleWorkflowFramework.NET.</param>
		/// <returns>Properly set up decision completed request.</returns>
		RespondDecisionTaskCompletedRequest IDecider.OnActivityTaskCompleted(WorkflowDecisionContext context)
		{
			try
			{
				Logger.Debug("");

				var res = NextStep(context, context.LastExecutionContext);

				return Respond(res);
			}
			catch (Exception ex)
			{
				return FailWorkflowRespond(ex.Message, "");
			}
		}

		/// <summary>
		/// Handles the activity task failed event.
		/// Retry the failed activity <see cref="ISchedulable.MaxAttempts"/> times in the event of an activity failing.
		/// </summary>
		/// <param name="context">Workflow decision context supplied by SimpleWorkflowFramework.NET.</param>
		/// <returns>Properly set up decision completed request.</returns>
		RespondDecisionTaskCompletedRequest IDecider.OnActivityTaskFailed(WorkflowDecisionContext context)
		{
			try
			{
				Logger.Error(context.Control);
				var res = RetryScheduled(context, context.LastExecutionContext);

				return Respond(res);
			}
			catch (Exception ex)
			{
				return FailWorkflowRespond(ex.Message, "");
			}
		}

		/// <summary>
		/// Retry the current step <see cref="ISchedulable.MaxAttempts"/> times before failing the workflow. 
		/// </summary>
		/// <param name="context">Workflow decision context supplied by SimpleWorkflowFramework.NET.</param>
		/// <returns>Properly set up decision completed request.</returns>
		RespondDecisionTaskCompletedRequest IDecider.OnActivityTaskTimedOut(WorkflowDecisionContext context)
		{
			try
			{
				context.Reason = $"Timeout: {context.TimeoutType}";
				var res = RetryScheduled(context, context.LastExecutionContext);

				return Respond(res);
			}
			catch (Exception ex)
			{
				return FailWorkflowRespond(ex.Message, "");
			}
		}

		/// <summary>
		/// Hendles the sc
		/// Set up a fail workflow decision in the event of a failure of scheduling a task.
		/// </summary>
		/// <param name="context">Workflow decision context supplied by SimpleWorkflowFramework.NET.</param>
		/// <returns>Properly set up decision completed request.</returns>
		RespondDecisionTaskCompletedRequest IDecider.OnScheduleActivityTaskFailed(WorkflowDecisionContext context)
		{
			try
			{
				Logger.Error(context.ActivityId);

				var activity = GetActivity(context.ActivityId);

				CallActivityFailed(activity, "", context.Cause);

				return FailWorkflowRespond(context.ActivityId, context.Cause);
			}
			catch (Exception e)
			{
				return FailWorkflowRespond(e.Message, "");
			}
		}

		/// <summary>
		/// Handles the child workflow execution started by returning an empty decision. 
		/// This could be modified in the future to handle parallel child workflow/activity invocations.
		/// </summary>
		/// <param name="context">Workflow decision context supplied by SimpleWorkflowFramework.NET.</param>
		/// <returns>Properly set up decision completed request.</returns>
		RespondDecisionTaskCompletedRequest IDecider.OnChildWorkflowExecutionStarted(WorkflowDecisionContext context) { return EmptyDecision(); }

		/// <summary>
		/// Set up a fail workflow decision in the event of a failure of scheduling a task.
		/// </summary>
		/// <param name="context">Workflow decision context supplied by SimpleWorkflowFramework.NET.</param>
		/// <returns>Properly set up decision completed request.</returns>
		RespondDecisionTaskCompletedRequest IDecider.OnChildWorkflowExecutionCompleted(WorkflowDecisionContext context)
		{
			try
			{
				var res = NextStep(context, context.LastExecutionContext);

				return Respond(res);
			}
			catch (Exception ex)
			{
				return FailWorkflowRespond(ex.Message, "");
			}
		}

		/// <summary>
		/// ReSets up a fail workflow decision in the event of a failure of a child workflow.
		/// </summary>
		/// <param name="context">Workflow decision context supplied by SimpleWorkflowFramework.NET.</param>
		/// <returns>Properly set up decision completed request.</returns>
		RespondDecisionTaskCompletedRequest IDecider.OnChildWorkflowExecutionFailed(WorkflowDecisionContext context)
		{
			try
			{
				var res = RetryScheduled(context, context.LastExecutionContext);

				return Respond(res);
			}
			catch (Exception ex)
			{
				return FailWorkflowRespond(ex.Message, "");
			}

			//return FailWorkflow(Resources.OnChildWorkflowExecutionFailed, context.Cause);
		}

		/// <summary>
		/// Set up a fail workflow decision in the event of termination of a child workflow.
		/// </summary>
		/// <param name="context">Workflow decision context supplied by SimpleWorkflowFramework.NET.</param>
		/// <returns>Properly set up decision completed request.</returns>
		RespondDecisionTaskCompletedRequest IDecider.OnChildWorkflowExecutionTerminated(WorkflowDecisionContext context) { return FailWorkflowRespond(Resources.OnChildWorkflowExecutionTerminated, context.Cause); }

		/// <summary>
		/// Re-tries the child workflow 3 times before failing the workflow.
		/// </summary>
		/// <param name="context">Workflow decision context supplied by SimpleWorkflowFramework.NET.</param>
		/// <returns>Properly set up decision completed request.</returns>
		RespondDecisionTaskCompletedRequest IDecider.OnChildWorkflowExecutionTimedOut(WorkflowDecisionContext context)
		{
			try
			{
				context.Reason = $"Timeout: {context.TimeoutType}";
				var res = RetryScheduled(context, context.LastExecutionContext);

				return Respond(res);
			}
			catch (Exception ex)
			{
				return FailWorkflowRespond(ex.Message, "");
			}
		}

		/// <summary>
		/// Set up a fail workflow decision in the event of failure to start a child workflow.
		/// </summary>
		/// <param name="context">Workflow decision context supplied by SimpleWorkflowFramework.NET.</param>
		/// <returns>Properly set up decision completed request.</returns>
		RespondDecisionTaskCompletedRequest IDecider.OnStartChildWorkflowExecutionFailed(WorkflowDecisionContext context)
		{
			try
			{
				var res = RetryScheduled(context, context.LastExecutionContext);

				return Respond(res);
			}
			catch (Exception ex)
			{
				return FailWorkflowRespond(ex.Message, "");
			}
			// TODO: Warning: maybe this way?
			//return FailWorkflowRespond("OnStartChildWorkflowExecutionFailed", context.Cause);
		}

		RespondDecisionTaskCompletedRequest IDecider.OnStartChildWorkflowExecutionInitiated(WorkflowDecisionContext context) { return EmptyDecision(); }

		RespondDecisionTaskCompletedRequest IDecider.OnWorkflowExecutionSignaled(WorkflowDecisionContext context) { return EmptyDecision(context.LastExecutionContext); }

		RespondDecisionTaskCompletedRequest IDecider.OnTimerStarted(WorkflowDecisionContext context) { return EmptyDecision(context.LastExecutionContext); }

		RespondDecisionTaskCompletedRequest IDecider.OnTimerFired(WorkflowDecisionContext context)
		{
			try
			{
				var decisions = new List<Decision>();

				foreach (var timer in context.FiredTimers)
				{
					if (context.Timers.ContainsKey(timer.Key) &&
						!context.CanceledTimers.ContainsKey(timer.Key))
					{
						var state = SchedulableStateSerializer.Deserialize(context.Timers[timer.Key].Control);

						if (state == null)
						{
							decisions.Clear();
							decisions.Add(FailWorkflow("State is undefined.", ""));
							break;
						}

						ISchedulable schedulable = GetScheduled(state);

						var activity = (IActivity)(/*(ICloneable)*/schedulable).Clone();

						// Start the appropriate activity at once.
						state.DelayTimeoutInSeconds = 0;

						// TODO: CRITICAL. Activity.Input is null for collection activity, 
						// therefore we have to get Input from a Marker related to the timer.
						if (context.Markers.ContainsKey(timer.Key))
						{
							//var marker = MarkerSerializer.Deserialize(context.Markers[timer.Key]);
							activity.Input = context.Markers[timer.Key]; // marker.Input;
						}

						// Run activity with desired input.
						decisions.AddRange(ScheduleActivity(state, activity.Input, activity));
					}
				}

				return Respond(new StepDecision(decisions, context.LastExecutionContext));
			}
			catch (Exception ex)
			{
				return FailWorkflowRespond(ex.Message, "");
			}
		}

		RespondDecisionTaskCompletedRequest IDecider.OnTimerCanceled(WorkflowDecisionContext context)
		{
			try
			{
				var wfState = context.LastExecutionContext;

				var decisions = new List<Decision>();

				foreach (var timer in context.CanceledTimers)
				{
					if (!context.Timers.ContainsKey(timer.Key))
					{
						continue;
					}
					var timerControl = context.Timers[timer.Key].Control;

					var state = SchedulableStateSerializer.Deserialize(timerControl);
					if (state == null)
					{
						continue;
					}
					var step = GetStep(state.StepNumber);

					if (step.Action is IParallelActivityCollection)
					{
						if (!wfState.Results.ContainsKey(state.ActionNumber))
						{
							// TODO: Warning: Call a delegate and to check if the activity can be ignored or the workflow should be stopped.

							// By default we just add empty result to ignore parallel activity.
							wfState.Results[state.ActionNumber] = ""; // Activity.TOutput
						}
					}
					else if (step.Action is IActivity)
					{
						// TODO: Warning: Call a delegate and to check if the activity can be ignored or the workflow should be stopped.

						// By default just go to the next step with using empty result.
						context.Control = timerControl;
						context.ResultRef = "";

						return Respond(NextStep(context, wfState));
					}
				}

				return Respond(new StepDecision(decisions, wfState));
			}
			catch (Exception ex)
			{
				return FailWorkflowRespond(ex.Message, "");
			}
		}

		#endregion IDecider Methods

		#region Decision Helpers

		/// <summary>
		/// Determines the next stege based on the current context.
		/// </summary>
		/// <returns>List of decisions to schedule new step.</returns>
		internal StepDecision NextStep(WorkflowDecisionContext decisionContext, WorkflowState wfState)
		{
			var state = SchedulableStateSerializer.Deserialize(decisionContext.Control);

			if (state == null)
			{
				return new StepDecision(FailWorkflow("State is undefined.", ""));
			}

			var step = GetStep(state.StepNumber);

			Logger.Info("");
			if (step == null)
			{
				return new StepDecision(CompleteWorkflow(decisionContext.ResultData), new WorkflowState(state.StepNumber));
			}

			// Handle IParallelXXXCollections
			var parallelCollection = step.Action as IParallelCollection;
			if (parallelCollection != null)
			{
				return ProcessActionCollection(decisionContext, wfState, state, parallelCollection, step);
			}

			// Handle ISuspendable
			var suspendable = step.Action as ISuspendable;
			if (suspendable != null)
			{
				return ProcessISuspendable(decisionContext, wfState, step, state);
			}

			// Handle simple IActivity
			return ProcessIActivity(decisionContext, step, state);
		}

		internal virtual StepDecision ProcessIActivity(WorkflowDecisionContext decisionContext, IWorkflowStep step, SchedulableState state)
		{
			Logger.Debug("IActivity");

			var res = decisionContext.ResultObject;
			if (res.Success)
			{
				var nextStep = ResolveStepNumber(step, decisionContext.ResultData, state.StepNumber + 1);

				return ScheduleStep(nextStep.StepNumber, nextStep.Input, 0);
			}
			CallActivityFailed(step.Action, decisionContext.Input, "Activity Failed");

			return new StepDecision(FailWorkflow(decisionContext.ResultData, "Activity Failed"),
				new WorkflowState(state.StepNumber));
		}

		/// <summary>
		/// For internal use only. Don't override.
		/// </summary>
		/// <param name="decisionContext"></param>
		/// <param name="wfState"></param>
		/// <param name="step"></param>
		/// <param name="state"></param>
		/// <returns></returns>
		internal virtual StepDecision ProcessISuspendable(WorkflowDecisionContext decisionContext, WorkflowState wfState,
			IWorkflowStep step, SchedulableState state)
		{
			Logger.Debug("ISuspendable");

			var res = decisionContext.ResultObject;
			var action = (IActivity)step.Action;

			var input = res.Success
				? res.ReturnValue
				: (string.IsNullOrEmpty(action.Input) ? decisionContext.Input : action.Input); // Use previous input.

			var nextStep = new StepResult()
			{
				StepNumber = state.StepNumber,
				Input = input
			};

			if (res.Success)
			{
				nextStep = ResolveStepNumber(step, res.ReturnValue, state.StepNumber + 1);
			}

			if (nextStep.StepNumber != state.StepNumber)
			{
				return ScheduleStep(nextStep.StepNumber, nextStep.Input, 0);
			}
			state.DelayTimeoutInSeconds = action.Options.DelayTimeoutInSeconds;
			state.AttemptNumber = 0;
			return new StepDecision(ScheduleActivity(state, input, action), wfState);
		}

		/// <summary>
		/// For internal use only. Don't override
		/// </summary>
		/// <param name="decisionContext"></param>
		/// <param name="wfState"></param>
		/// <param name="state"></param>
		/// <param name="parallelCollection"></param>
		/// <param name="step"></param>
		/// <returns></returns>
		internal virtual StepDecision ProcessActionCollection(WorkflowDecisionContext decisionContext, WorkflowState wfState,
			SchedulableState state, IParallelCollection parallelCollection, IWorkflowStep step)
		{
			Logger.Debug("IParallelActivityCollection. TotalActions: [{0}]", state.TotalActions);

			// TODO: check why the wfState is null. Maybe we dont need it at all.
			if (wfState == null)
			{
				wfState = new WorkflowState(state.StepNumber)
				{
					NumberOfActions = state.TotalActions
				};
			}

			// Get the results from the step so far and update the results of the workflow.
			var results = decisionContext.Results[state.StepNumber]; //  GetStepResults(state.StepNumber);

			// if all the results are in, then aggregate them with the Reducer and schedule the next step
			// otherwise, do nothing, and simply update the current workflow
			if (results == null || state.TotalActions != results.Count)
			{
				return new StepDecision(wfState);
			}
			var result = CallReducer(parallelCollection, results);

			var nextStep = ResolveStepNumber(step, result, state.StepNumber + 1);

			return ScheduleStep(nextStep.StepNumber, nextStep.Input, 0);
			// Workflow %s's step %d is expected to be ParallelActions.
			// TODO: NotImplemented. NextStep() -> step.Action is NOT IParallelActivityCollection => Exception or Failed Step ?
			/*
								throw new NotImplementedException();
			*/
		}

		internal virtual string CallReducer(IParallelCollection parallelCollection, Dictionary<int, string> results)
		{
			var parallelAction = parallelCollection;
			var resList = results
				.Select(item => Utils.DeserializeFromJSON<StepResult<object>>(Utils.GetDataFromStore(item.Value, _storageClient)))
				.Select(resObj => Utils.SerializeToJSON(resObj.ReturnValue)).ToList();

			// Run Reducer bot here.
			var result = parallelAction.Reducer(resList);
			return result;
		}

		/// <summary>
		/// Set up decisions to schedule nth (zero-indexed) step with given an input and number of attempts.
		/// </summary>
		/// <param name="stepNum">Zero based index of step to be scheduled.</param>
		/// <param name="input">Input data passed to the scheduled step.</param>
		/// <param name="attempts">Number of spent attempts.</param>
		/// <returns>List of decisions to schedule step.</returns>
		internal virtual StepDecision ScheduleStep(int stepNum, string input, int attempts)
		{
			var step = GetStep(stepNum);

			Logger.Info("");
			// Either all steps have been processed or the stepNum is incorrect.
			if (step == null)
			{
				return new StepDecision(CompleteWorkflow(input), new WorkflowState(stepNum));
			}


			var wfState = new WorkflowState(step.StepNumber);

			var decisions = new List<Decision>();

			var action = step.Action;

			if (action is IParallelCollection)
			{
				var parallel = action as IParallelCollection;

				//parallel.Schedulers = new ConcurrentBag<ISchedulable>();

				var actionInput = "";

				if (action is IWorkflow)
				{
					actionInput = (action as IWorkflow).Input;
				}
				else if (action is IActivity)
				{
					actionInput = (action as IActivity).Input;
				}

				input = string.IsNullOrEmpty(actionInput) ? input : actionInput;

				IEnumerable<ICollectionItemInput> inputs = parallel.Processor(input);

				var collectionItemInputs = inputs as IList<ICollectionItemInput> ?? inputs.ToList();
				wfState.NumberOfActions = collectionItemInputs.Count();
				int index = 0;
				foreach (var data in collectionItemInputs)
				{
					var state = new SchedulableState
					{
						StepNumber = step.StepNumber,
						StepKey = step.StepKey,
						ActionNumber = index,
						AttemptNumber = 1,
						MaxAttempts = action.MaxAttempts,
						TotalActions = wfState.NumberOfActions
					};

					IWorkflow workflow = action as IWorkflow;
					if (workflow != null)
					{
						var wf = (IWorkflow)workflow.Clone();
						//wf.Input = data.Input;

						decisions.Add(ScheduleChildWorkflow(state, data.Input, wf));

						//parallel.Schedulers.Add(wf);
					}
					else if (action is IActivity)
					{
						state.DelayTimeoutInSeconds = data.DelayTimeoutInSeconds;

						var activity = (IActivity)(/*(ICloneable)*/action).Clone();

						activity.Options.DelayTimeoutInSeconds = data.DelayTimeoutInSeconds;
						activity.Input = data.Input;

						decisions.AddRange(ScheduleActivity(state, data.Input, activity));

						//parallel.Schedulers.Add(activity);
					}

					index++;
				}
			}

			else if (action is IWorkflow)
			{
				//var workflow = (IWorkflow)((ICloneable)action).Clone();
				var workflow = (IWorkflow)action;

				// If workflow.Input is empty, we pass the input from the previous step.
				input = string.IsNullOrEmpty(workflow.Input) ? input : workflow.Input;

				decisions.Add(ScheduleChildWorkflow(0, 1, step.StepNumber, step.StepKey, attempts, input, workflow));

				// wfState has default value.
			}

			else if (action is IActivity)
			{
				//var activity = (IActivity)((ICloneable)action).Clone();
				var activity = (IActivity)action;

				// If activity.Input is empty, pass the input from previous step.
				input = string.IsNullOrEmpty(activity.Input) ? input : activity.Input;

				decisions.AddRange(ScheduleActivity(0, 1, step.StepNumber, step.StepKey, 0, input, activity));

				// wfState has default value.
			}

			else
			{
				decisions.Add(FailWorkflow($"Unsuppoted step type. Step: {step.StepNumber}", ""));
			}

			return new StepDecision(decisions, wfState);
		}

		/// <summary>
		/// Set up decision to retry a step if it was timed out or failed.
		/// </summary>
		/// <param name="context">Workflow decision context supplied by SimpleWorkflowFramework.NET.</param>
		/// <param name="wfState">Current workflow state</param>
		/// <returns>List of decisions to re-schedule step.</returns>
		/// <remarks>Based on result of <see cref="CallActivityFailed"/> it also can return decisions to schedule next step.</remarks>
		internal virtual StepDecision RetryScheduled(WorkflowDecisionContext context, WorkflowState wfState)
		{
			var state = SchedulableStateSerializer.Deserialize(context.Control);

			if (state == null)
			{
				return new StepDecision(FailWorkflow(context.Details, "State is undefined."));
			}

			// Get the scheduled action that failed, raise the appropriate event
			ISchedulable schedulable = GetScheduled(state);

			var decisions = new List<Decision>();

			if (state.AttemptNumber >= state.MaxAttempts)
			{
				var details = context.Details;

				if (schedulable is IActivity)
				{
					details = $"Activity exceeded Max Attempts: {details}";
					CallActivityFailed(schedulable, details, context.Reason);
				}
				else
				{
					details = $"Workflow exceeded Max Attempts: {details}";
					CallWorkflowFailed(details, context.Reason);
				}

				decisions.Add(FailWorkflow(details, context.Reason));
			}
			else
			{
				state.AttemptNumber++;

				if (schedulable is IActivity)
				{
					// Since the activity was already scheduled once, this should not be passed via the timer case.
					state.DelayTimeoutInSeconds = 0;

					decisions.AddRange(ScheduleActivity(state, context.Input, (IActivity)schedulable));
				}
				else if (schedulable is IWorkflow)
				{
					decisions.Add(ScheduleChildWorkflow(state.ActionNumber, state.TotalActions, state.StepNumber, state.StepKey,
						state.AttemptNumber,
						context.Input, (IWorkflow)schedulable));
				}
			}

			return new StepDecision(decisions, wfState);
		}


		/// <summary>
		/// Set up decision to schedule an activity.
		/// </summary>
		/// <param name="input">Activity input</param>
		/// <param name="activity">Activity to be scheduled.</param>
		/// <param name="actionNum">action number for parallel activity collection</param>
		/// <param name="totalActions">total parallel activity collection capacity</param>
		/// <param name="stepNum">Current step number in workflow sequence</param>
		/// <param name="stepKey">ID of activity</param>
		/// <param name="attempts">attempts number for retrying a failing action</param>
		/// <returns>Decision to schedule activity.</returns>
		internal virtual List<Decision> ScheduleActivity(int actionNum, int totalActions, int stepNum, string stepKey, int attempts,
			string input,
			IActivity activity)
		{
			var state = new SchedulableState
			{
				StepNumber = stepNum,
				StepKey = stepKey,
				ActionNumber = actionNum,
				AttemptNumber = attempts + 1,
				MaxAttempts = activity.Options.MaxAttempts,
				TotalActions = totalActions,
				DelayTimeoutInSeconds = activity.Options.DelayTimeoutInSeconds
			};

			return ScheduleActivity(state, input, activity);
		}

		/// <summary>
		/// Returns the decision to schedule an activity.
		/// </summary>
		/// <param name="state">Meta data about the step.</param>
		/// <param name="input">Data to be processed.</param>
		/// <param name="activity">Activity to be scheduled.</param>
		internal virtual List<Decision> ScheduleActivity(SchedulableState state, string input, IActivity activity)
		{
			activity.ActivityId = GetActionId(activity.Name, state);
			//activity.Input = input;

			if (activity is ISuspendable)
			{
				//Logger.Error("Suspendable. StartedDate: {0}", state.StartedDate);

				if (state.StartedDate == DateTime.MinValue)
				{
					state.StartedDate = DateTime.UtcNow;
				}

				Logger.Info("Suspendable. StartedDate: {0}, {1}", state.StartedDate, ((ISuspendable)activity).WaitingTimeInSeconds);

				if (state.StartedDate.AddSeconds(((ISuspendable)activity).WaitingTimeInSeconds) < DateTime.UtcNow)
				{
					Logger.Error("Suspendable activity exceeded waiting time.");

					CallActivityFailed(activity, activity.Name, "Suspendable activity exceeded waiting time.");

					return new List<Decision>
					{
						FailWorkflow(activity.ActivityId, "Suspendable activity exceeded waiting time.")
					};

					// TODO: or Complete workflow!?
				}
			}

			if (state.DelayTimeoutInSeconds > 0)
			{
				return ScheduleTimer(state, input, activity);
			}

			Logger.Fatal("[{0}] [{1}].", activity.ActivityId, input);

			var attributes = new ScheduleActivityTaskDecisionAttributes
			{
				ActivityId = activity.ActivityId,
				ActivityType = new ActivityType
				{
					Name = activity.Name,
					Version = activity.Options.Version
					// This should be defined within Workflow.Register() method. //GetActivityVersion(Domain, Version, state.StepNumber, activity)
				},
				TaskList = activity.TaskList,
				Input = Utils.PutDataToStore(input, _storageClient),
				HeartbeatTimeout = activity.Options.HeartbeatTimeout.ToStringOrNone(),
				ScheduleToCloseTimeout = activity.Options.ScheduleToCloseTimeout.ToStringOrNone(),
				ScheduleToStartTimeout = activity.Options.ScheduleToStartTimeout.ToStringOrNone(),
				StartToCloseTimeout = activity.Options.StartToCloseTimeout.ToStringOrNone(),
				Control = SchedulableStateSerializer.Serialize(state), // activityContext.Control,
			};

			return new List<Decision>
			{
				new Decision
				{
					DecisionType = DecisionType.ScheduleActivityTask,
					ScheduleActivityTaskDecisionAttributes = attributes,
				}
			};
		}

		/// <summary>
		/// Returns decision of a record marker.
		/// Marker stores <see cref="SchedulableState.ActionNumber"/> and <see cref="IActivity.Input"/>.
		/// This data is used in <see cref="IDecider.OnTimerFired"/> when it's occured for a Parallel Activity 
		/// the corresponding Marker will be used to schedule the activity.
		/// </summary>
		private Decision RecordMarker(string markerId, string input)
		{
			Logger.Fatal("[{0}] [{1}].", markerId, input);

			var attributes = new RecordMarkerDecisionAttributes
			{
				Details = Utils.PutDataToStore(input, _storageClient), //MarkerSerializer.Serialize(new Marker { ActionNumber = state.ActionNumber, Input = input }),
				MarkerName = markerId
			};

			return new Decision
			{
				DecisionType = DecisionType.RecordMarker,
				RecordMarkerDecisionAttributes = attributes,
			};
		}

		/// <summary>
		/// Returns the decision to schedule a timer.
		/// </summary>
		/// <param name="state">Current workflow state - <see cref="SchedulableState"/></param>
		/// <param name="input">timer input</param>
		/// <param name="activity">Activity to be delayed.</param>
		internal virtual List<Decision> ScheduleTimer(SchedulableState state, string input, IActivity activity)
		{
			Logger.Fatal("[{0}] [{1}] StartToFire: {2} seconds.", activity.Name, activity.ActivityId, state.DelayTimeoutInSeconds);

			var decisions = new List<Decision>();

			var attributes = new StartTimerDecisionAttributes
			{
				TimerId = GetActionId("timer." + activity.Name, state),
				StartToFireTimeout = state.DelayTimeoutInSeconds.ToString(),
				Control = SchedulableStateSerializer.Serialize(state) //timer.Control
			};

			decisions.Add(new Decision
			{
				DecisionType = DecisionType.StartTimer,
				StartTimerDecisionAttributes = attributes
			});
			decisions.Add(RecordMarker(attributes.TimerId, input));

			return decisions;
		}

		/// <summary>
		/// Set up decision to schedule a child workflow. 
		/// </summary>
		/// <param name="totalActions">for parallel collections</param>
		/// <param name="stepNum">Zero based index of step to be scheduled.</param>
		/// <param name="actionNum">Zero based index of action within the step to be scheduled.</param>
		/// <param name="stepKey">unique step ID</param>
		/// <param name="attempts">Number of spent attempts.</param>
		/// <param name="input">Data to be processed.</param>
		/// <param name="workflow">Workflow to be scheduled.</param>
		/// <returns>Decision to schedule a child workflow.</returns>
		internal virtual Decision ScheduleChildWorkflow(int actionNum, int totalActions, int stepNum, string stepKey, int attempts,
			string input,
			IWorkflow workflow)
		{
			var state = new SchedulableState
			{
				StepNumber = stepNum,
				StepKey = stepKey,
				ActionNumber = actionNum,
				AttemptNumber = attempts + 1,
				MaxAttempts = workflow.MaxAttempts,
				TotalActions = totalActions
			};


			return ScheduleChildWorkflow(state, input, workflow);
		}

		/// <summary>
		/// Set up decision to schedule a child workflow. 
		/// </summary>
		/// <param name="state">complex workflow state object, <see cref="SchedulableState"/></param>
		/// <param name="input">Data to be processed.</param>
		/// <param name="workflow">Workflow to be scheduled.</param>
		/// <returns>Decision to schedule a child workflow.</returns>
		internal virtual Decision ScheduleChildWorkflow(SchedulableState state, string input, IWorkflow workflow)
		{
			workflow.WorkflowId = ((WorkflowBase)workflow).GetWorkflowId(workflow.Name, state);
			var attributes = new StartChildWorkflowExecutionDecisionAttributes
			{
				WorkflowId = workflow.WorkflowId,
				WorkflowType = new WorkflowType
				{
					Name = workflow.Name,
					Version = workflow.Options.Version
				},
				ChildPolicy = workflow.ChildPolicy,
				Input = Utils.PutDataToStore(input, _storageClient), //workflow.Input,

				TaskList = workflow.TaskList,
				TagList = workflow.TagList,
				ExecutionStartToCloseTimeout = workflow.Options.ExecutionStartToCloseTimeout.ToString(),
				TaskStartToCloseTimeout = workflow.Options.TaskStartToCloseTimeout.ToStringOrNone(),
				Control = SchedulableStateSerializer.Serialize(state),
			};

			return new Decision
			{
				DecisionType = DecisionType.StartChildWorkflowExecution,
				StartChildWorkflowExecutionDecisionAttributes = attributes
			};
		}

		/// <summary>
		/// Set up decision to complete workflow.
		/// </summary>
		/// <param name="result">Result of workflow execution that is a result of the last activity in the workflow.</param>
		/// <returns>Decision to complete workflow.</returns>
		internal virtual Decision CompleteWorkflow(string result)
		{
			//Logger.Info("");
			Logger.Info("Name: {3}, RunId: {0}, _workflowExecutionStarted: {1}, /nResult: {2}", RunId, _workflowExecutionStarted, result, Name);

			// Casting the result to last activity TOutput
			var lastActivity = GetLastActivityStep(this);
			if (lastActivity != null && !string.IsNullOrWhiteSpace(result))
			{
				var data = lastActivity.GetTypedObject(result);

				Result = Utils.SerializeToJSON(new StepResult<object>(data, true));
			}
			else
				Result = Utils.SerializeToJSON(new StepResult<string>(result, true));

			CallWorkflowCompleted(result);

			var attributes = new CompleteWorkflowExecutionDecisionAttributes
			{
				Result = Utils.PutDataToStore(Result, _storageClient)
			};

			return new Decision
			{
				DecisionType = DecisionType.CompleteWorkflowExecution,
				CompleteWorkflowExecutionDecisionAttributes = attributes
			};
		}




		/// <summary>
		/// Set up decision to fail workflow.
		/// </summary>
		/// <param name="details">Failure details.</param>
		/// <param name="reason">Reason for the failure.</param>
		/// <returns>Properly set up decision.</returns>
		internal virtual Decision FailWorkflow(string details, string reason)
		{
			Logger.Fatal("Details: {0} \nReason: {1}.", details, reason);

			var attributes = new FailWorkflowExecutionDecisionAttributes
			{
				Details = details,
				Reason = reason
			};

			return new Decision
			{
				DecisionType = DecisionType.FailWorkflowExecution,
				FailWorkflowExecutionDecisionAttributes = attributes
			};
		}

		/// <summary>
		/// Creates a Respond Decision to complete workflow.
		/// </summary>
		/// <param name="result"></param>
		/// <returns></returns>
		internal RespondDecisionTaskCompletedRequest CompleteWorkflowRespond(string result)
		{
			var decisionRequest = new RespondDecisionTaskCompletedRequest();

			Logger.Info("");
			var completeDecision = CompleteWorkflow(result);

			if (completeDecision != null)
			{
				decisionRequest.Decisions.Add(completeDecision);
			}

			StopWorkers();

			_workflowExecutionStarted = false;

			return decisionRequest;
		}

		/// <summary>
		/// Creates a Respond Decision to cancel workflow.
		/// </summary>
		/// <param name="details">Details for the cancellation.</param>
		/// <returns>Properly set up decision completed request.</returns>
		internal RespondDecisionTaskCompletedRequest CancelWorkflowRespond(string details)
		{
			var attributes = new CancelWorkflowExecutionDecisionAttributes
			{
				Details = details
			};

			var decisionRequest = new RespondDecisionTaskCompletedRequest
			{
				Decisions = new List<Decision>
				{
					new Decision
					{
						DecisionType = DecisionType.CancelWorkflowExecution,
						CancelWorkflowExecutionDecisionAttributes = attributes
					}
				}
			};

			StopWorkers();

			Debug.WriteLine(">>> Decision: CancelWorkflowExecution");

			_workflowExecutionStarted = false;

			return decisionRequest;
		}

		/// <summary>
		/// Creates a Respond Decision to fail workflow.
		/// </summary>
		/// <param name="details">Failure details.</param>
		/// <param name="reason">Reason for the failure.</param>
		/// <returns>Properly set up decision completed request.</returns>
		internal RespondDecisionTaskCompletedRequest FailWorkflowRespond(string details, string reason)
		{
			CallWorkflowFailed(details, reason);

			var decisionRequest = new RespondDecisionTaskCompletedRequest
			{
				Decisions = new List<Decision>
				{
					FailWorkflow(details, reason)
				}
			};

			StopWorkers();

			_workflowExecutionStarted = false;

			return decisionRequest;
		}

		/// <summary>
		/// Helper method to create a record marker decision.
		/// </summary>
		/// <param name="details"></param>
		/// <param name="markerName"></param>
		/// <returns>Properly set up decision completed request.</returns>
		/*protected RespondDecisionTaskCompletedRequest RecordMarker(string details, string markerName)
		{
			var attributes = new RecordMarkerDecisionAttributes
			{
				Details = details,
				MarkerName = markerName
			};

			var decisionRequest = new RespondDecisionTaskCompletedRequest
			{
				Decisions = new List<Decision>
				{
					new Decision
					{
						DecisionType = DecisionType.RecordMarker,
						RecordMarkerDecisionAttributes = attributes
					}
				}
			};

			Debug.WriteLine(">>> Decision: RecordMarker [" + attributes.MarkerName + "] = " + attributes.Details);
			return decisionRequest;
		}*/
		/// <summary>
		/// Helper method to create an empty decision request.
		/// </summary>
		/// <returns>Properly set up decision completed request.</returns>
		private RespondDecisionTaskCompletedRequest EmptyDecision()
		{
			var decisionRequest = new RespondDecisionTaskCompletedRequest
			{
				Decisions = new List<Decision>()
			};

			Debug.WriteLine(">>> Decision: <EMPTY>");
			return decisionRequest;
		}

		/// <summary>
		/// Helper method to create an empty decision request.
		/// </summary>
		/// <param name="wfState">Used for execution context.</param>
		/// <returns>Properly set up decision completed request.</returns>
		private RespondDecisionTaskCompletedRequest EmptyDecision(WorkflowState wfState)
		{
			var decisionRequest = new RespondDecisionTaskCompletedRequest
			{
				Decisions = new List<Decision>(),
				ExecutionContext = WorkflowStateSerializer.Serialize(wfState)
			};

			return decisionRequest;
		}

		#endregion Decision Helpers

		#region Amazon Calls

		/// <summary>
		/// Sends request to start an execution of the workflow type.
		/// </summary>
		private bool CallWorkflowExecution(string input)
		{
			Logger.Info("");

			StartWorkflowExecutionResponse response = _swfClient.StartWorkflowExecutionAsync(new StartWorkflowExecutionRequest
			{
				WorkflowId = WorkflowId,
				Domain = Options.Domain,
				WorkflowType = new WorkflowType
				{
					Name = Name,
					Version = Options.Version
				},
				Input = input,
				ChildPolicy = ChildPolicy,
				TaskList = TaskList,
				TagList = TagList,
				ExecutionStartToCloseTimeout = Options.ExecutionStartToCloseTimeout.ToString(),
				TaskStartToCloseTimeout = Options.TaskStartToCloseTimeout.ToStringOrNone(),
			}).Result;

			if (response.HttpStatusCode == System.Net.HttpStatusCode.OK)
			{
				RunId = response.Run.RunId;

				return true;
			}

			return false;
		}

		/// <summary>
		/// Registers Domain, Workflow and child activities.
		/// </summary>
		/// <param name="domainName">Domain to be registered.</param>
		/// <param name="client">Interface for accessing Amazon Simple Workflow Service.</param>
		void IRegistrable.Register(string domainName, IAmazonSimpleWorkflow client) { Register(client); }

		/// <summary>
		/// Registers Domain, Workflow and child activities.
		/// </summary>
		/// <param name="client">Interface for accessing Amazon Simple Workflow Service.</param>
		/// <remarks>Goes through all steps and registers domain, workflow types, child workflow types and activity types.</remarks>
		private void Register(IAmazonSimpleWorkflow client)
		{
			Debug.Assert(client != null);

			Logger.Info("--> Start");

			// Register Domain if not already registered.
			RegisterDomain(client);

			// Register Workflow Type if not already registered.
			RegisterWorkflow(client);

			// Registering child activities.
			foreach (var step in Steps)
			{
				//var activity = step.Action as IActivity;
				//if (activity != null)
				//	activity.Version = GetActivityVersion(Name, Version, step.StepNumber, activity);

				var registrable = step.Action as IRegistrable;
				registrable?.Register(Options.Domain, client);
			}

			Logger.Info("<-- End");
		}

		/// <summary>
		/// Requests all registered domains and registers <see cref="Domain"/> of the instance 
		/// if it's not registered yet.
		/// </summary>
		/// <param name="client">Interface for accessing Amazon Simple Workflow Service.</param>
		private void RegisterDomain(IAmazonSimpleWorkflow client)
		{
			var listDomainRequest = new ListDomainsRequest
			{
				RegistrationStatus = RegistrationStatus.REGISTERED
			};

			if (client.ListDomainsAsync(listDomainRequest).Result.DomainInfos.Infos.FirstOrDefault(x => x.Name == Options.Domain) == null)
			{
				Logger.Trace("New Domain.");

				RegisterDomainRequest request = new RegisterDomainRequest
				{
					Name = Options.Domain,
					Description = Description,
					WorkflowExecutionRetentionPeriodInDays = Options.WorkflowExecutionRetentionPeriodInDays.ToStringOrNone()
				};

				client.RegisterDomainAsync(request).Wait();
			}

			Logger.Trace("Domain: {0}. Workflow {1}", Options.Domain, Name);
		}

		/// <summary>
		/// Requests all registered workflow types within <see cref="Domain"/> and registers type of the instance 
		/// if it's not registered yet.
		/// </summary>
		/// <param name="client">Interface for accessing Amazon Simple Workflow Service.</param>
		private void RegisterWorkflow(IAmazonSimpleWorkflow client)
		{
			var listWorkflowRequest = new ListWorkflowTypesRequest
			{
				Name = Name,
				Domain = Options.Domain,
				RegistrationStatus = RegistrationStatus.REGISTERED
			};

			if (
				client.ListWorkflowTypesAsync(listWorkflowRequest).Result
					.WorkflowTypeInfos.TypeInfos.FirstOrDefault(x => x.WorkflowType.Version == Options.Version) == null)
			{
				Logger.Trace("New Workflow Type.");

				RegisterWorkflowTypeRequest request = new RegisterWorkflowTypeRequest
				{
					Domain = Options.Domain,
					Name = Name,
					Version = Options.Version,
					DefaultChildPolicy = ChildPolicy,
					DefaultTaskList = TaskList, // Decider need to poll for this task
					DefaultExecutionStartToCloseTimeout = Options.ExecutionStartToCloseTimeout.ToString(),
					DefaultTaskStartToCloseTimeout = Options.TaskStartToCloseTimeout.ToStringOrNone()
				};

				client.RegisterWorkflowTypeAsync(request).Wait();
			}

			Logger.Trace("Workflow: {0}, Version: {1}.", Name, Options.Version);
		}

		void IRegistrable.Validate() { Validate(); }

		private void Validate()
		{
			ValidateOptions();

			// Validate children.
			foreach (var step in Steps)
			{
				var registrable = step.Action as IRegistrable;
				registrable?.Validate();
			}
		}

		protected virtual void ValidateOptions()
		{
			string message = Options.Name + ". '{0}' is undefined.";
			//if (Options == null)
			//	throw new ArgumentNullException("Options");

			//throw new NotImplementedException();
			if (string.IsNullOrEmpty(Options.Domain))
				throw new Exception(string.Format(message, "Domain"));

			if (string.IsNullOrEmpty(Options.Name))
				throw new Exception(string.Format(message, "Name"));

			if (string.IsNullOrEmpty(Options.Version))
				throw new Exception(string.Format(message, "Version"));

			if (string.IsNullOrEmpty(Options.TaskList))
				throw new Exception(string.Format(message, "TaskList"));

			// NOTE it is not required.
			//if (Options.NextStepHandler == null)
			//	throw new Exception("Property 'NextStepHandler' is undefined.");
		}

		#endregion

		#region Utility Methods

		/// <summary>
		/// Validates key corresponded to an action.
		/// The key should be defined and has unique value within workflow.
		/// </summary>
		/// <param name="stepKey"></param>
		private void ValidateKey(string stepKey)
		{
			if (string.IsNullOrWhiteSpace(stepKey))
			{
				throw new ArgumentException("The key is undefined.", nameof(stepKey));
			}

			if (Steps.Any(s => s.StepKey == stepKey))
			{
				throw new ArgumentException($"The key '{stepKey}' is already used in collection.", nameof(stepKey));
			}
		}

		/// <summary>
		/// Gets the nth (zero-index) step. Don't override this
		/// </summary>
		internal virtual IWorkflowStep GetStep(int n) { return (n > -1 && n < Steps.Count ? Steps.ElementAt(n) : null); }

		internal virtual IActivity GetLastActivityStep(WorkflowBase wf)
		{
			var item = wf?.Steps.Last();
			if (item == null)
				return null;
			
			if (item.Action is IActivity)
				return (IActivity) item.Action;
			else
				return  GetLastActivityStep((WorkflowBase)item.Action);
		}

		/// <summary>
		/// Based on the result of <see cref="WorkflowBase.GetNextStep(string,string)"/> method retrieves the step number of the next action to be scheduled.
		/// </summary>
		/// <param name="currentStep">current step number in sequence</param>
		/// <param name="input"></param>
		/// <param name="defaultStepNumber">
		/// Value to be used if the method <see cref="WorkflowBase.GetNextStep(string,string)"/> is not overrided or returns nothing.
		/// </param>
		/// <returns>Number of the next step.</returns>
		internal virtual StepResult ResolveStepNumber(IWorkflowStep currentStep, string input, int defaultStepNumber)
		{
			// Call custom step decider.
			IResult<object> resolution = GetNextStep(currentStep.StepKey, input);

			if (resolution != null && !string.IsNullOrEmpty(resolution.StepKey))
			{
				var step = Steps.FirstOrDefault(s => s.StepKey.Equals(resolution.StepKey, StringComparison.OrdinalIgnoreCase));
				if (step != null)
				{
					defaultStepNumber = step.StepNumber;
					input = Utils.SerializeToJSON(resolution.ReturnValue);
				}
			}

			return new StepResult
			{
				StepNumber = defaultStepNumber,
				Input = input
			};
		}

		/// <summary>
		/// Returns an action (<see cref="IActivity"/> or child <see cref="IWorkflow"/>) corresponded to the current <see cref="SchedulableState"/> data.
		/// </summary>
		/// <param name="state">Details of the current step.</param>
		/// <returns>Step action.</returns>
		internal virtual ISchedulable GetScheduled(SchedulableState state)
		{
			Debug.Assert(state != null);

			var step = GetStep(state.StepNumber);

			Debug.Assert(step != null);

			var action = step.Action;
			//if (action is IParallelActivityCollection)
			//{
			//	return ((IParallelActivityCollection)action).Schedulers.ElementAt(state.ActionNumber);
			//}
			//if (action is IWorkflow)
			//	return ((WorkflowBase)action).GetScheduled(state);

			return action;
		}


		/*private List<IActivity> Activities
		{
			get
			{
				List<IActivity> list = new List<IActivity>();

				foreach (var step in Steps)
				{
					if (step.Action is IParallelActivityCollection)
					{
						var parallel = (IParallelActivityCollection)step.Action; 
						if (parallel.Schedulers != null)
							list.AddRange(parallel.Schedulers.Select(s => (IActivity)s));
					}
					else if (step.Action is IActivity)
					{
						list.Add((IActivity)step.Action);
					}
				}

				return list;
			}
		}

		// TODO: Critical. This cannot be used when we have several independent deciders or activity workers. 
		// In this case activityId will be different within each decider.
		internal IActivity GetActivity(string activityId)
		{
			Logger.Debug(activityId);

			Debug.Assert(!string.IsNullOrEmpty(activityId));

			foreach (var activity in Activities)
				if (activityId.Equals(activity.ActivityId, StringComparison.InvariantCultureIgnoreCase))
					return activity;

			return null;
		}*/


		/// <summary>
		/// Sets activity version.
		/// </summary>
		/// <param name="stepNum">Step number of activity.</param>
		/// <param name="activity">Activity instance.</param>
		private void SetActivityVersion(int stepNum, IActivity activity)
		{
			activity.LockVersion(Utils.CreateActivityVersion(stepNum, Options.Name, Options.Version, activity.Options.Version));
		}

		/// <summary>
		/// Generates unique compound ID of the instance based on the current <see cref="SchedulableState"/> data.
		/// </summary>
		/// <param name="name">Name of activity.</param>
		/// <param name="state">Data corresponding to the current step.</param>
		/// <returns>Unique Id matched to template WorkflowPath__{Name}._{StepNumber}._{ActionNumber}._{Attempt}</returns>
		/// <remarks>
		/// The specified string must not start or end with whitespace. 
		/// It must not contain a : (colon), / (slash), | (vertical bar), or any control characters (\u0000-\u001f | \u007f - \u009f). 
		/// Also, it must not contain the literal string "arn".
		/// Length constraints: Minimum length of 1. Maximum length of 256.
		/// </remarks>
		private string GetActionId(string name, SchedulableState state)
		{
			return Utils.CreateActionId(name.TrimForID(), TreePath, state.StepNumber, state.ActionNumber, state.AttemptNumber);
		}

		private string GetWorkflowId(string name, SchedulableState state)
		{
			return Utils.CreateWorkflowId(name, TreePath, state.StepNumber, state.ActionNumber, state.AttemptNumber);
		}

		/// <summary>
		/// Returns an actvity instance.
		/// </summary>
		/// <param name="activityId">Unique activity Id.</param>
		public IActivity GetActivity(string activityId)
		{
			// We cannot search for event in the history list using task.StartedEventId because it may not exist there yet.
			// So just parse value ActivityId (e.g. TreePath__Name._StepNum._ActionNum._Attempts) to get Step and Activity numbers.

			var wf = this;

			string[] treeKeys = activityId.Split(new[] { Utils.PathDelimiter }, StringSplitOptions.None);

			if (treeKeys.Length != 0 && !string.IsNullOrEmpty(treeKeys[0]))
			{
				string[] path = treeKeys[0].Split(new[] { '.' }, StringSplitOptions.RemoveEmptyEntries);

				wf = FindWorkflow(path);
			}

			MatchCollection mc = Regex.Matches(activityId, @"_(\d+)\.");
			if (mc.Count != 2)
			{
				return null;
			}

			int stepNum;
			if (!int.TryParse(mc[0].Groups[1].Value, out stepNum))
			{
				return null;
			}

			int actionNum;
			if (int.TryParse(mc[1].Groups[1].Value, out actionNum))
			{
				return (IActivity)wf.GetScheduled(new SchedulableState
				{
					StepNumber = stepNum,
					ActionNumber = actionNum
				});
			}

			return null;
		}


		/// <summary>
		/// Returns workflow instance for which IDecider's methods should be called.
		/// </summary>
		/// <param name="workflowId">ID to be parsed.</param>
		/// <returns></returns>
		public IDecider GetDecider(string workflowId)
		{
			string[] treeKeys = workflowId.Split(new[] { Utils.PathDelimiter }, StringSplitOptions.None);

			if (treeKeys.Length == 0 || string.IsNullOrEmpty(treeKeys[0]))
			{
				WorkflowId = workflowId;
				return this;
			}

			string[] path = treeKeys[0].Split(new[] { '.' }, StringSplitOptions.RemoveEmptyEntries);

			var wf = FindWorkflow(path);
			if (wf != null)
			{
				wf.WorkflowId = workflowId;
			}

			return wf;
		}

		/// <summary>
		/// Walks through the workflow tree using appropriate path. 
		/// It checks if the current workflow execution is starting with child workflow.
		/// </summary>
		/// <param name="path">Array of indexes.</param>
		/// <returns>current workflow or child workflow</returns>
		internal WorkflowBase FindWorkflow(string[] path)
		{
			if (path.Length > 0)
			{
				var index = int.Parse(path[0]);
				var step = GetStep(index);

				if (step == null)
				{
					return null;
				}

				if (step.Action is IWorkflow)
				{
					return ((WorkflowBase)step.Action).FindWorkflow(path.Skip(1).ToArray());
				}
			}

			return this;
		}

		/// <summary>
		/// Prepends path to all child workflow.
		/// </summary>
		/// <param name="parentPath">Path to be prepended.</param>
		internal void PrependTreePath(string parentPath)
		{
			if (!string.IsNullOrEmpty(parentPath))
			{
				TreePath = $"{parentPath}{(string.IsNullOrEmpty(TreePath) ? "" : "." + TreePath)}";

				foreach (var step in Steps)
				{
					if (step.Action is IWorkflow)
					{
						((WorkflowBase)step.Action).PrependTreePath(parentPath);
					}
				}
			}
		}		
		
		#endregion Utility Methods



		/// <summary>
		/// Caller for the <see cref="WorkflowBase.WorkflowCompleted"/> event.
		/// </summary>
		/// <param name="result">Result of the workflow execution.</param>
		private void CallWorkflowCompleted(string result)
		{
			// Casting the result to a typed object.
			object data = result;

			var lastStep = Steps.Last();
			if (lastStep != null && lastStep.Action is IActivity)
			{
				data = ((IActivity)lastStep.Action).GetTypedObject(result);
			}

			// WTF??? why we dont pass the instance?
			OnWorkflowCompleted(new WorkflowEventArgs(data));
		}

		/// <summary>
		/// Raises the <see cref="WorkflowBase.WorkflowCompleted"/> event.
		/// </summary>
		/// <param name="e">An <see cref="ll.SDK.Workflow.WorkflowEventArgs"/> that contains the event data.</param>
		protected virtual void OnWorkflowCompleted(WorkflowEventArgs e)
		{
			try
			{
				WorkflowCompleted?.Invoke(this, e);
			}
			catch (Exception ex)
			{
				FailWorkflowRespond(ex.Message, "");
			}
		}

		/// <summary>
		/// Caller for the <see cref="WorkflowBase.WorkflowFailed"/> event.
		/// </summary>
		/// <param name="details">The details of the failure.</param>
		/// <param name="reason">The reason provided for the failure</param>
		private void CallWorkflowFailed(string details, string reason)
		{
			OnWorkflowFailed(new WorkflowEventArgs(details, reason));
		}

		/// <summary>
		/// Raises the <see cref="WorkflowBase.WorkflowFailed"/> event.
		/// </summary>
		/// <param name="e">An <see cref="ll.SDK.Workflow.WorkflowEventArgs"/> that contains the event data.</param>
		protected virtual void OnWorkflowFailed(WorkflowEventArgs e)
		{
			try
			{
				WorkflowFailed?.Invoke(this, e);
			}
			catch (Exception ex)
			{
				FailWorkflowRespond(ex.Message, "Failed to fail workflow");
			}
		}

		/// <summary>
		/// Caller for the <see cref="WorkflowBase.ActivityFailed"/> event.
		/// </summary>
		/// <param name="action">Failed Activity</param>
		/// <param name="details">The details of the failure.</param>
		/// <param name="reason">The reason provided for the failure.</param>
		private void CallActivityFailed(ISchedulable action, string details, string reason)
		{
			var e = new ActivityEventArgs(details, reason);
			OnActivityFailed(action, e);
		}

		/// <summary>
		/// Raises the <see cref="WorkflowBase.ActivityFailed"/> event.
		/// </summary>
		/// <param name="action">Failed Activity</param>
		/// <param name="e">An <see cref="ll.SDK.Workflow.ActivityEventArgs"/> that contains the event data.</param>
		protected virtual void OnActivityFailed(ISchedulable action, ActivityEventArgs e)
		{
			try
			{
				ActivityFailed?.Invoke(action, e);
			}
			catch (Exception ex)
			{
				FailWorkflowRespond(ex.Message, ""); //TODO fail activity respond?
			}
		}

		/// <summary>
		/// Attaches an <see cref="IActivity"/> or child <see cref="IWorkflow"/> as the next step of a workflow.
		/// </summary>
		public WorkflowBase AttachStep(ISchedulable action)
		{
			var stepKey = Steps.Count.ToString();

			AttachStep(stepKey, action);

			return this;
		}

		/// <summary>
		/// Attaches an <see cref="IActivity"/> or child <see cref="IWorkflow"/> as the next step of a workflow.
		/// </summary>
		public WorkflowBase AttachStep(string stepKey, ISchedulable action)
		{
			// Prevent to update steps sequence if the workflow is already started.
			if (_committed)
				return this;

			// Nothing to do if the action is undefined.
			if (action == null)
				return this;

			ValidateKey(stepKey);

			var step = new WorkflowStep()
			{
				StepKey = stepKey,
				StepNumber = Steps.Count,
				Action = action
			};

			Steps.Add(step);

			if (action is IWorkflow)
			{
				((WorkflowBase)action).PrependTreePath(step.StepNumber.ToString());
			}

			// Version should be assigned before a <see cref="RegisterActivityTypeRequest"> will be sent.
			var activity = action as IActivity;
			if (activity != null)
			{
				SetActivityVersion(step.StepNumber, activity);
			}

			return this;
		}

		/// <summary>
		/// Starts Workflow execution. Invokes all the async workflow code and waits for entire workflow to complete
		/// </summary>
		/// <param name="input">Serialized input object passed to the first step.</param>
		/// <param name="defaultCancellationToken">default if not specified</param>
		/// <returns>Workflow result serialized in string</returns>
		public string StartWorkflow(string input, CancellationToken defaultCancellationToken = default(CancellationToken))
		{
			ParallelOptions options = new ParallelOptions
			{
				CancellationToken = defaultCancellationToken
			};

			Parallel.Invoke(options, () =>
			{
				Result = RunWorkflow(input, defaultCancellationToken);
			});

			return Result;
		}

		/// <summary>
		/// Starts Workflow execution asynchonously. Task return value will be the entire workwlow result
		/// </summary>
		/// <param name="input">Serialized input object passed to the first step.</param>
		/// <param name="defaultCancellationToken">default if not specified</param>
		/// <returns>Task with Workflow result serialized in string</returns>
		public Task<string> StartWorkflowAsync(string input, CancellationToken defaultCancellationToken = default(CancellationToken))
		{
			return Task.Run(() => RunWorkflow(input, defaultCancellationToken), defaultCancellationToken);
		}

		private string RunWorkflow(string input, CancellationToken defaultCancellationToken)
		{
			if (Steps.Count == 0)
			{
				Result = "";
				return input;
			}

			Validate();

			_committed = true;

			Input = input;

			// Sets Unique identifier for the execution.
			WorkflowId = GetWorkflowId(Name, new SchedulableState
			{
				StepNumber = 0,
				ActionNumber = 0,
				AttemptNumber = 1
			});

			Logger.Debug("WorkflowId: {0} /nInput: {1}.", WorkflowId, Input);

			// Registering Activities a child Workflows.
			if (_checkRegisterTypes)
			{
				Register(_swfClient);
			}

			input = Utils.PutDataToStore(input, _storageClient);
			_workflowExecutionStarted = CallWorkflowExecution(input);

			StartWorkers();

			while (_workflowExecutionStarted)
			{
				if (defaultCancellationToken.IsCancellationRequested)
				{
					Result = "";
					Logger.Warn("Workflow execution has been canceled.");
					break;
				}
			}

			while (_executedWorkers.Count > 0)
			{
				if (_executedWorkers[0].IsCompleted)
				{
					_executedWorkers.RemoveAt(0);
				}
			}

			return Result;
		}


		/// <summary>
		/// Stops all inside workers.
		/// </summary>
		public void Stop()
		{
			_committed = false;

			StopWorkers();
		}

		/// <summary>
		/// Starts inside <see cref="WorkflowEventsProcessor"/> and <see cref="ActivityWorker"/> workers.
		/// </summary>
		/// <param name="defaultCancellationToken"></param>
		internal void StartWorkers(CancellationToken defaultCancellationToken = default(CancellationToken))
		{
			var tokenSource = new CancellationTokenSource();
			if (_tokenSources.ContainsKey(WorkflowId))
			{
				tokenSource = _tokenSources[WorkflowId];
			}
			else
			{
				_tokenSources[WorkflowId] = tokenSource;
			}

			var cancellationToken = defaultCancellationToken == default(CancellationToken)
				? tokenSource.Token
				: defaultCancellationToken;

			// Run Worflow Worker (incapsulation WorkflowEventsProcessor).
			if (_useInsideDecider)
			{
				_executedWorkers.Add(StartDecider(cancellationToken));
			}

			// Run Activity Worker.
			if (_useInsideActivityWorker)
			{
				_executedWorkers.Add(StartActivityWorker(cancellationToken));
			}
		}

		/// <summary>
		/// Stops all inside workers.
		/// </summary>
		internal void StopWorkers()
		{
			Logger.Info("StopWorkers -->: " + WorkflowId);
			if (!_workflowExecutionStarted)
			{
				return;
			}

			if (_tokenSources.ContainsKey(WorkflowId))
			{
				var tokenSource = _tokenSources[WorkflowId];
				if (tokenSource != null)
				{
					tokenSource.Cancel();
					Logger.Info("WorkflowID: " + WorkflowId);
				}
			}
		}

		/// <summary>
		/// Starts independent workflow and activity workers.
		/// </summary>
		/// <param name="defaultCancellationToken"></param>
		public void ExecuteWorkers(CancellationToken defaultCancellationToken = default(CancellationToken))
		{
			if (defaultCancellationToken == default(CancellationToken))
			{
				var tokenSource = new CancellationTokenSource();
				defaultCancellationToken = tokenSource.Token;
			}

			//if (!_workflowExecutionStarted)
			{
				StartDecider(defaultCancellationToken);
				StartActivityWorker(defaultCancellationToken);
			}
		}

		/// <summary>
		/// Starts decider worker <see cref="WorkflowEventsProcessor"/> in a separate thread.
		/// </summary>
		/// <param name="defaultCancellationToken">Propagates notification that decider should be stopped.</param>
		public Task StartDecider(CancellationToken defaultCancellationToken = default(CancellationToken))
		{
			Logger.Info("");
			return new WorkflowWorker(this, _swfClient, _storageClient).Start(defaultCancellationToken);
		}

		/// <summary>
		/// Starts activity worker <see cref="ActivityWorker"/> in a separate thread.
		/// </summary>
		/// <param name="defaultCancellationToken">Propagates notification that worker should be stopped.</param>
		public Task StartActivityWorker(CancellationToken defaultCancellationToken = default(CancellationToken))
		{
			Logger.Info("");
			return new ActivityWorker(this, _swfClient, _storageClient).Start(defaultCancellationToken);
		}

		protected virtual void ValidateTypes()
		{
			//Utils.ValidateType(typeof(TInput));
			//Utils.ValidateType(typeof(TOutput));
		}

		#region ICloneable Members

		public object Clone()
		{
			var clone = (WorkflowBase)MemberwiseClone();
			HandleCloned(clone);
			return clone;
		}

		protected virtual void HandleCloned(WorkflowBase clone)
		{
			//Nothing particular in the base class, but maybe usefull for childs.
			//Not abstract so childs may not implement this if they don't need to.
		}

		#endregion

		//public static void TestLogger(string message)
		//{
		//	Logger.Trace(message + " Trace");
		//	Logger.Debug(message + " Debug");
		//	Logger.Info(message + " Info");
		//	Logger.Warn(message + " Warn");
		//	Logger.Error(message + " Error");
		//	Logger.Fatal(message + " Fatal");
		//}

	}
}